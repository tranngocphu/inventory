name: Deploy to EKS

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy'
        required: true
        default: 'prod'
      branch:
        description: 'Branch to deploy from'
        required: true
        default: 'main'

env:
  AWS_REGION: us-east-1
  EKS_CLUSTER_NAME: inventory-cluster
  DOCKER_IMAGE: ${{ secrets.DOCKER_USERNAME }}/inventory

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code from specified branch
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.inputs.branch }}  # Use the input branch

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.22'

      - name: Build and Test
        run: |
          go test ./... -v
          go build -o inventory ./cmd/inventory

      - name: Log in to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Build and Push Docker Image
        run: |
          docker build -t ${{ env.DOCKER_IMAGE }}:${{ github.sha }} -f docker/Dockerfile .
          docker push ${{ env.DOCKER_IMAGE }}:${{ github.sha }}

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Install eksctl
        run: |
          curl --silent --location "https://github.com/eksctl-io/eksctl/releases/latest/download/eksctl_$(uname -s)_amd64.tar.gz" | tar xz -C /tmp
          sudo mv /tmp/eksctl /usr/local/bin
          eksctl version

      - name: Debug IAM Permissions
        run: |
          aws sts get-caller-identity
          aws eks list-clusters --region ${{ env.AWS_REGION }}
          aws eks describe-cluster-versions --name ${{ env.EKS_CLUSTER_NAME }} --region ${{ env.AWS_REGION }} || echo "Expected if cluster not yet created"

      - name: Pre-Create Security Group for Nodes
        id: create-sg
        run: |
          # Get default VPC ID
          VPC_ID=$(aws ec2 describe-vpcs --region ${{ env.AWS_REGION }} --filters Name=isDefault,Values=true --query 'Vpcs[0].VpcId' --output text)
          if [ -z "$VPC_ID" ]; then
            echo "Error: No default VPC found in ${{ env.AWS_REGION }}"
            exit 1
          fi

          # Define SG name with run ID for uniqueness
          SG_NAME="inventory-eks-nodes-${{ github.run_id }}"

          # Check if SG exists (capture output explicitly)
          SG_ID=$(aws ec2 describe-security-groups --region ${{ env.AWS_REGION }} --filters Name=group-name,Values=$SG_NAME --query 'SecurityGroups[0].GroupId' --output text 2>/dev/null)
          if [ "$SG_ID" = "null" ] || [ -z "$SG_ID" ]; then
            # Create SG if it doesn't exist
            SG_ID=$(aws ec2 create-security-group --group-name $SG_NAME --description "EKS nodes SG for inventory" --vpc-id $VPC_ID --region ${{ env.AWS_REGION }} --query 'GroupId' --output text)
            if [ -z "$SG_ID" ]; then
              echo "Error: Failed to create security group"
              exit 1
            fi
            aws ec2 create-tags --resources $SG_ID --tags Key=Name,Value=$SG_NAME --region ${{ env.AWS_REGION }}
            aws ec2 authorize-security-group-ingress --group-id $SG_ID --protocol tcp --port 30080 --cidr 0.0.0.0/0 --region ${{ env.AWS_REGION }}
            echo "Created SG: $SG_ID"
          else
            echo "SG $SG_ID already exists, reusing it"
          fi

          # Output SG_ID for later steps
          echo "SG_ID=$SG_ID" >> $GITHUB_OUTPUT

      - name: Update cluster.yaml with Security Group
        run: |
          # Backup original cluster.yaml
          cp deployments/eks/cluster.yaml deployments/eks/cluster.yaml.bak
          # Use yq to add securityGroups.attachIDs (install yq first)
          sudo curl -L https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64 -o /usr/local/bin/yq
          sudo chmod +x /usr/local/bin/yq
          yq eval '.managedNodeGroups[0].securityGroups.attachIDs = ["${{ steps.create-sg.outputs.SG_ID }}"]' -i deployments/eks/cluster.yaml
          cat deployments/eks/cluster.yaml  # Debug: Show updated file
      
      - name: Create or Update EKS Cluster
        run: |
          # Check if cluster exists
          if eksctl get cluster --name ${{ env.EKS_CLUSTER_NAME }} --region ${{ env.AWS_REGION }} > /dev/null 2>&1; then
            echo "Cluster ${{ env.EKS_CLUSTER_NAME }} already exists, skipping creation."
          else
            echo "Creating cluster ${{ env.EKS_CLUSTER_NAME }}..."
            eksctl create cluster -f deployments/eks/cluster.yaml
          fi

      - name: Update kubeconfig
        run: |
          eksctl utils write-kubeconfig --cluster ${{ env.EKS_CLUSTER_NAME }} --region ${{ env.AWS_REGION }}

      - name: Deploy to EKS
        run: |
          kubectl create secret generic db-credentials --from-literal=postgres-password=${{ secrets.POSTGRES_PASSWORD }} --dry-run=client -o yaml | kubectl apply -f -
          kubectl apply -f deployments/k8s/postgres-deployment.yaml
          sed "s|{{DOCKER_IMAGE}}|${{ env.DOCKER_IMAGE }}:${{ github.sha }}|g" deployments/k8s/inventory-deployment.yaml | kubectl apply -f -

      - name: Verify Deployment
        run: |
          kubectl get pods --all-namespaces
          kubectl get svc
          echo "Homepage URL: http://$(kubectl get nodes -o jsonpath='{.items[0].status.addresses[?(@.type=="ExternalIP")].address}'):30080"